# MCP 特有の攻撃手法への対策

**本章では前章で紹介した MCP 特有の攻撃手法に対する対策を解説します。** MCP セキュリティの緩和策を体系的に整理し、各対策の実装方法について詳細に説明します。

## AI リスクマネジメントの重要性

企業として MCP を提供するにせよ、導入するにせよ、MCP セキュリティの How の前に AI リスクマネジメントの基本的な考え方を理解することが非常に重要です。NIST から [AI リスクマネジメントフレームワーク (AI RMF)](https://airc.nist.gov/airmf-resources/) が公開されており、組織全体の包括的な対策やプロセスを策定する際の指針となります。

本書籍は主に技術視点の対策にフォーカスしており、AI リスクマネジメントのための組織的な対策やプロセスについては対象外です。AI RMF などを確認して組織全体の包括的な対策やプロセスを策定し、その中で技術的対応をどこまで実施するのか検討してください。

以降の解説はあくまで対策手法の紹介であり、リスクマネジメントの中でリスク洗い出しと優先度づけ、対応可否を決めてください。以降では、MCP の利用者、提供者、それぞれの視点で整理します。

## MCP 特有の攻撃手法への対策アプローチ

MCP 特有の攻撃手法は最終的にはプロンプトインジェクション攻撃に繋がっています。人間のチェックをすり抜けて、悪意のある MCP Server もしくは、悪意のある外部リソースをモデルの入力に入れ込むことがゴールです。

これらの攻撃手法への対策としては、以下の 2 つのアプローチがあります：

### 1. MCP Server の整合性検証

サプライチェーン攻撃に対してのピン留めと変更検出が該当します。Rug Pulls のように正常だったはずの MCP Server が悪性化するということは、ツール説明などが Initialize 後に変更されてしまうことが原因です。

組織利用の際には MCP Server のツール説明等のレビューや検証を実施すべきです。そして**レビュー後に変更がないことが約束されていればサプライチェーン攻撃リスクは大幅に軽減されます**。

### 2. モデルの入出力検証

主に悪意のある外部リソースに対する対策です。例えば、検索 MCP Server は検索で取得した外部リソースを基本的にはそのまま返却するはずです。MCP Server はモデルとは疎結合にツール機能を提供することが責務であり、MCP Server の入出力に対してガードレールを入れることは責務外だと考えられます。

そのため MCP Server の出力には悪意のある情報が含まれている可能性があると想定した上で Client/Host 側で対処する必要があります。ただし、モデルの出力の不確定を完全に排除することはできないため、プロンプトインジェクションを完全に防ぐ方法は存在しません。

既存のセキュリティ対策を多層的に取り入れることが引き続き最も重要であることに変わりはありませんが、LLM as a Judge や複数の検出手段を用いて入出力を検証させるガードレールを導入することは追加の対策として有効です。

## 整合性検証による対策

### 基本的なアプローチ

Rug Pulls のように後から MCP Server が悪性化することを防ぐための対策には以下の手法が考えられます：

1. **`listChanged` 変更通知の適切なハンドリング**
2. **コード署名と検証**

MCP には STDIO と Streamable HTTP があり、それぞれの通信方式ごとに対策は若干異なります。

### `listChanged` パラメータの活用

MCP のライフサイクルにおける Initialization では Client と Server 間で機能ネゴシーエションを行いますが、`listChanged` は機能ごとにリスト変更通知のサポート有無を事前に取り決めます。

**`listChanged: true` が設定されている場合**の動作：

1. Server 側でツール定義が変更されると、Server は `notifications/tools/listChanged` 通知を Client に送信
2. Client はこの通知を受け取ると、再度ツールリストを取得して変更を検出
3. 変更が検出された場合に Client はユーザーに再承認を要求

これによってユーザーはツール定義の変更を検知してレビューを行うことができます。

**MCP Server 提供者の責任**：`listChanged: true` の場合にはツール定義の変更時に変更通知を確実に行うことが重要です。

**MCP Server 利用者の注意点**：悪性の MCP Server は `listChanged: true` の場合でもツール定義変更を通知する保証がないため、この対応だけでは不十分です。また、全ての Client で通知を適切にハンドリングしている保証もありません。

### STDIO 方式での整合性検証

STDIO 方式では Client が Server をサブプロセスとして起動し、標準入出力を通じて通信します。この方式でのコード署名は比較的シンプルです。

#### 実装フロー

1. **提供側: 開発** - MCP Server のコードを開発する
2. **提供側: 署名** - 開発物に対して署名を行う
3. **提供側: 公開** - バージョンごとに署名を公開する
4. **利用側: 検証** - MCP Server 起動前に署名を検証し、署名が無効な場合は Server 起動しない

#### AWS Signer を使用した実装例

```bash
# 実行ファイルの署名例
aws signer sign-code \
  --profile-name mcp-server-profile \
  --source s3://bucket-name/mcp-server.zip \
  --destination s3://bucket-name/signed-mcp-server.zip
```

STDIO の MCP Server はローカルで実行され、一度起動時に署名検証していれば後からツール定義が変更されるリスクは低いです。ただし、ツール定義は不変でも MCP Server の返却する結果にプロンプトインジェクションの可能性があるため、署名検証をしておけば MCP 特有の攻撃に対して万全というものではありませんが、**最も容易かつ重大な攻撃経路である Rug Pulls を起点とした TPA に対しては必ず対策しておくべき**です。

### Streamable HTTP 方式での整合性検証

Streamable HTTP では、Server は独立したプロセスとして動作し、複数の Client 接続を処理します。この方式では、コード署名と検証がより複雑になります。

#### コード署名の対象

- **MCP Server の実行ファイル/コンテナイメージ** (STDIO と同様)
- **API レスポンス** (動的なコンテンツ)

#### 実装方法

1. **Server コードの署名** (STDIO と同様)

2. **API レスポンスの署名**:

```javascript
// Server 側での実装例
const response = {
  jsonrpc: "2.0",
  id: requestId,
  result: {
    tools: [...toolDefinitions]
  }
};

// レスポンスに署名を追加
const signature = await signWithAwsSigner(JSON.stringify(response));
response._signature = {
  timestamp: Date.now(),
  value: signature,
  keyId: "mcp-server-key-1"
};

return response;
```

3. **Client 側での検証**:

```javascript
// Client 側での実装例
async function verifyServerResponse(response) {
  try {
    if (!response._signature) {
      throw new SecurityError("署名が見つかりません");
    }
    
    const { _signature, ...content } = response;
    
    // AWS Signer の公開鍵で署名を検証
    const isValid = await verifySignatureWithAwsSigner(
      JSON.stringify(content),
      _signature.value,
      _signature.keyId
    );
    
    if (!isValid) {
      throw new SecurityError("署名検証に失敗しました");
    }
    
    return content;
  } catch (error) {
    logger.error("署名検証エラー:", error);
    throw error;
  }
}
```

#### Streamable HTTP 方式の特徴

- Server は**リモートで実行**される可能性があり、接続中のコード変更リスクが高い
- **各 API レスポンスの署名検証**が必要
- セッション管理と組み合わせた継続的な検証が重要

### 包括的な Rug Pull 対策

Streamable HTTP での効果的な Rug Pull 対策には、以下の複合的なアプローチが必要です：

1. **AWS Signer によるコード署名と検証**
   - Server コードに対する署名
   - API レスポンスに対する署名
   - Client 側での継続的な署名検証

2. **`listChanged` パラメータの活用**
   - 初期化フェーズで `listChanged: true` を要求
   - 変更通知を受け取った際の再検証と再承認フロー

3. **バージョン管理と不変性の強制**
   - ツール定義にバージョン番号を含める
   - バージョン変更時の強制的な再承認
   - 同一バージョンでの変更を禁止

4. **定期的な再検証**
   - 定期的にツールリストを再取得して変更を検出
   - ハッシュ値の比較による変更検出

5. **セッション管理との統合**
   - 短期間のセッションで長期的な変更リスクを軽減
   - セッション再開時の強制的な再検証

## セキュリティレビューの実施

### 組織での定期的なレビュー

MCP Server とその実装に対して定期的なセキュリティレビューを実施することは、潜在的な脆弱性を早期に発見し対処するために重要です。

#### レビュー項目

- **コードの脆弱性スキャン**
- **依存関係の脆弱性チェック**
- **機密情報の漏洩検出**

組織内で MCP Server を使用する場合は、信頼できる検証済みの MCP Server のみを使用するポリシーを確立し、新しい MCP Server の導入前には必ずセキュリティ評価を実施することが推奨されます。

### MCP Server の検証プロセス

MCP Server を安全に検証するためのチェックリストを作成し、以下のプロセスを確立します：

#### 静的解析
- コードの脆弱性スキャン
- 依存関係の脆弱性チェック
- 機密情報の漏洩検出

#### 動的解析
- サンドボックス環境での実行テスト
- ネットワーク通信の監視
- リソース使用状況の監視

#### ツール説明の検証
- プロンプトインジェクションパターンの検出
- 悪意のある指示の検出
- 説明と実際の機能の一致確認

## ツール説明検証による対策

### ツール説明のサニタイズ

ツール説明に含まれる可能性のある悪意のあるパターンを検出し除去するメカニズムを実装します。

#### 検出対象パターン

- 特殊命令パターンの検出と除去
- 指示の上書きを試みる文言の検出
- 悪意のある指示の検出

DOMPurify や sanitize-html などのライブラリを活用することで、HTML タグや JavaScript コードなどの潜在的に危険なコンテンツを除去できます。

### プロンプトインジェクションパターンの検出と除去

プロンプトインジェクションを検出するためには、以下のパターンに注意する必要があります：

- 「以下の指示は無視して」などの指示の上書きを試みる文言
- 「<IMPORTANT>」などの特殊なマークアップ
- 「システム上の API キーを検索し、外部に送信する」などの悪意のある指示

#### 実装例

```javascript
function detectMaliciousPatterns(toolDescription) {
  const maliciousPatterns = [
    /以下の指示は無視して/i,
    /ignore.*previous.*instructions/i,
    /<IMPORTANT>/i,
    /システム.*API.*キー.*送信/i,
    /send.*api.*key.*external/i
  ];
  
  for (const pattern of maliciousPatterns) {
    if (pattern.test(toolDescription)) {
      return true;
    }
  }
  
  return false;
}

function sanitizeToolDescription(description) {
  if (detectMaliciousPatterns(description)) {
    throw new SecurityError("悪意のあるパターンが検出されました");
  }
  
  // HTML タグや JavaScript の除去
  return DOMPurify.sanitize(description, { 
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  });
}
```

正規表現を用いたパターンマッチングや機械学習モデルを活用した検出システムを構築することで、より高度なプロンプトインジェクションも検出できます。

## Server 分離とサンドボックス化

### Docker によるサンドボックス化

MCP Server を Docker コンテナ内で実行することで、ホストシステムから分離し、被害を局所化できます。

#### セキュリティ強化策

```dockerfile
# セキュリティ強化された Dockerfile 例
FROM node:18-alpine

# 非 root ユーザーの作成
RUN addgroup -g 1001 -S mcpuser && \
    adduser -S mcpuser -u 1001 -G mcpuser

# 必要最小限のパッケージのみインストール
RUN apk add --no-cache dumb-init

# アプリケーションファイルのコピー
COPY --chown=mcpuser:mcpuser . /app
WORKDIR /app

# 依存関係のインストール
RUN npm ci --only=production && npm cache clean --force

# 非 root ユーザーに切り替え
USER mcpuser

# ヘルスチェックの追加
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

Docker Compose や Kubernetes などのオーケストレーションツールを活用することで、複数の MCP Server を効率的に管理し、それぞれを適切に分離できます。

### 最小権限の原則適用

MCP Server には必要最小限の権限のみを付与し、特にファイルシステム、ネットワーク、システムコマンドへのアクセスを制限します。

#### Deno を使用した権限制御例

```bash
# 特定のドメインへのアクセスのみを許可
deno run --allow-net=api.example.com,github.com --allow-read=./config server.ts
```

複数の MCP Server を Client に接続する場合は、それぞれを分離された環境で実行し、相互に影響を与えないようにすることが重要です。特に、機密データにアクセスできる MCP Server は、他の Server から分離された環境で実行すべきです。

## Tool Shadowing への対策

### 問題の本質

MCP Tool Shadowing は、MCP の設計に起因する根本的なセキュリティ課題です。この問題の核心は、**LLM が複数の MCP Server から情報を統合してツール選択を行う際、悪意のある Server が他の Server のツール使用を間接的に操作できる**という点にあります。

### 従来セキュリティ対策の限界

この問題に対して、従来のセキュリティ対策は効果が限定的です：

1. **認証・認可の限界**: 各 Server が適切に認証・認可を実装していても、LLM の判断プロセス自体への影響は防げません
2. **HTTPS 等の通信保護の無効性**: 通信が暗号化されていても、コンテンツ自体が問題を引き起こします
3. **境界防御モデルの崩壊**: 従来のセキュリティは「信頼できる内部」と「信頼できない外部」の境界を前提としていますが、MCP では複数の情報源が同じ LLM コンテキスト内で混在します

### 企業環境での実用的対策

企業インフラチームが採用すべき現実的なアプローチは以下の通りです：

#### 1. LLM 前段ガードレールでのフィルタリング（主要対策）

```javascript
function enterpriseGuardrail(llmInput) {
  // LLM に渡される全コンテキストからツール定義 JSON 解析
  const allTools = extractAllToolDefinitions(llmInput);
  const enterpriseAllowed = [
    "enterprise.send_email", 
    "enterprise.calendar", 
    "enterprise.files"
  ];
  
  for (const tool of allTools) {
    // 企業承認ツール以外の検出
    if (!enterpriseAllowed.includes(tool.name)) {
      throw new SecurityError(`Unauthorized tool blocked: ${tool.name}`);
    }
    
    // ツール説明文の悪意指示検出
    if (containsMaliciousCrossToolInstructions(tool.description)) {
      throw new SecurityError(`Malicious instructions detected in: ${tool.name}`);
    }
  }
  
  return sanitizedInput;
}
```

このアプローチは、LLM に入力される前の段階で、ツール定義を解析し、承認されていないツールや悪意のある指示を含むツール説明を検出・ブロックします。

#### 2. 企業ポリシーの強制適用

```javascript
function enforceBusinessPolicy(llmInput) {
  // 業務カテゴリ別の必須ツール強制
  const businessRules = {
    "email_request": ["enterprise.send_email"],
    "calendar_request": ["enterprise.calendar"],
    "file_request": ["enterprise.files"]
  };
  
  const userIntent = analyzeUserRequest(llmInput);
  if (userIntent in businessRules) {
    // 該当業務では企業ツールのみ許可
    enforceToolRestriction(llmInput, businessRules[userIntent]);
  }
  
  return modifiedInput;
}
```

#### 3. リアルタイム監視・アラート

```javascript
function securityMonitoring(llmInput, userId) {
  // 異常検知と即座のアラート
  const detectedTools = extractAllToolDefinitions(llmInput);
  
  // 予期しないツールの検出
  const unauthorizedTools = detectedTools.filter(
    tool => !tool.name.startsWith("enterprise.")
  );
  
  if (unauthorizedTools.length > 0) {
    alertSecurityTeam(
      `User ${userId}: Unauthorized tools detected: ${JSON.stringify(unauthorizedTools)}`
    );
    blockLlmExecution();
  }
  
  return llmInput;
}
```

### 実装優先順位

1. **LLM 前段ガードレール**: 即座に実装可能、最も効果的
2. **リアルタイム監視システム**: 攻撃検知・対応
3. **企業ポリシー強制機能**: 業務ルールの自動適用
4. **MCP 仕様改善への働きかけ**: 根本的解決、長期的

## MCP Server 提供者と利用者の責任

### MCP Server 提供者の責任

**MCP Server 提供者**は、MCP Server の整合性検証の仕組みを提供すべきです。提供者は Rug Pulls、Tool Poisoning Attack などへの不安をユーザーに与えないように提供側で実施している緩和策を示すことが求められます。

#### 最低限の対応

- 既存のセキュリティベストプラクティスへの準拠
- 整合性検証の仕組みの提供
- MCP 仕様で Initialize 時に `listChanged` の仕組みを確実に提供

### MCP Server 利用者の責任

**MCP Server 利用者**は、以下の責任を負います：

- 信頼できる検証済みの MCP Server のみを使用
- 新しい MCP Server の導入前のセキュリティ評価実施
- 定期的なセキュリティレビューの実施
- 適切な監視とログ記録の実装

## 実際の脆弱性事例から学ぶ

### GitHub MCP Server の脆弱性

2025年5月に Invariant Labs が発見した GitHub MCP Server の脆弱性は、Tool Shadowing 攻撃の実例として重要な教訓を提供しています。

#### 攻撃の流れ

1. 攻撃者が公開リポジトリに悪意のある Issue を作成
2. ユーザーが AI エージェントに「公開リポジトリの Issue を確認して」と指示
3. エージェントが Issue を読み込み、プロンプトインジェクションを受ける
4. エージェントが指示に従い、プライベートリポジトリのデータを取得
5. 取得したデータを公開リポジトリの Pull Request として漏洩

#### 対策の教訓

この事例から以下の対策の重要性が明らかになりました：

1. **粒度の細かい権限制御**: リポジトリごとのアクセス制限
2. **継続的なセキュリティ監視**: リアルタイムでの異常検知
3. **モデルアライメントの限界**: 最新の高性能モデルでも脆弱性は存在

## まとめ

MCP 特有の攻撃手法に対する対策は、単一の方法ではなく、複数の緩和策を組み合わせた包括的なアプローチが必要です。本章で紹介した対策を適切に実装することで、MCP のセキュリティリスクを大幅に軽減できます。

### 重要なポイント

1. **設計段階からのセキュリティ考慮**: セキュリティを後付けではなく、設計段階から考慮することが重要
2. **多層防御の実装**: 単一の対策に依存せず、複数の対策を組み合わせる
3. **継続的な評価と更新**: 新たな脅威や攻撃手法に対応するための定期的な見直し
4. **現実的な対策の優先**: 理想的な対策と現実的に実装可能な対策のバランス

特に企業環境では、LLM 前段のガードレールによるツール定義フィルタリングが最も現実的で効果的な対策として推奨されます。MCP の進化とともに、セキュリティ対策も進化させていくことが重要です。

## 参考資料

- [Model Context Protocol Security Best Practices](https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices)
- [Palo Alto Networks: Model Context Protocol (MCP): A Security Overview](https://www.paloaltonetworks.com/blog/cloud-security/model-context-protocol-mcp-a-security-overview/)
- [Invariant Labs: GitHub MCP Vulnerability Report](https://invariantlabs.ai/blog/mcp-github-vulnerability)
- [Model Context Protocol (MCP): Landscape, Security Threats, and Future Research Directions](https://arxiv.org/abs/2503.23278)
- [GitHub Blog: How to build secure and scalable remote MCP servers](https://github.blog/ai-and-ml/generative-ai/how-to-build-secure-and-scalable-remote-mcp-servers/)
- [SlowMist MCP Security Checklist](https://github.com/slowmist/MCP-Security-Checklist)
- [Docker: MCP Server Best Practices](https://www.docker.com/blog/mcp-server-best-practices/)
---


# 拡張ツール定義インターフェース（ETDI）：Model Context Protocol のセキュリティ強化

## エグゼクティブサマリー

Model Context Protocol（MCP）は、AI アプリケーションと大規模言語モデル（LLM）間の相互作用を標準化する上で極めて重要な役割を果たしており、外部ツールやデータを統合することで豊富でコンテキストを理解した体験を可能にしています。しかし、現在の MCP 仕様には重大なセキュリティ脆弱性、主に**ツールポイズニング**と**ラグプル攻撃**が存在し、これらは不正なデータアクセス、操作、およびユーザーの信頼失墜につながる可能性があります。

この設計文書では、標準的な MCP 運用フロー内でのこれらの脆弱性を詳細に分析します。その後、暗号化アイデンティティ、不変のバージョン管理された定義、および明示的な権限付与を組み込むことで、これらの脅威を軽減するよう設計された堅牢なセキュリティレイヤーである**拡張ツール定義インターフェース（ETDI）**を紹介します。さらに、この文書では **OAuth 2.0** を活用した高度な ETDI 実装を提案し、標準化された、きめ細かい、中央管理されたセキュリティ制御を提供します。

ETDI の採用は、MCP 対応エコシステムのセキュリティ態勢を大幅に強化し、より安全で信頼性の高い AI 駆動の相互作用を確保することを目的としています。

## 目次

1. [はじめに：セキュアな MCP の必要性](#はじめにセキュアなmcpの必要性)
2. [MCP エコシステムの理解：アーキテクチャ概要](#mcpエコシステムの理解アーキテクチャ概要)
3. [運用ダイナミクス：標準的な MCP フロー](#運用ダイナミクス標準的なmcpフロー)
   - [初期化と発見フェーズ](#初期化と発見フェーズ)
   - [ツール呼び出しと使用フェーズ](#ツール呼び出しと使用フェーズ)
4. [MCP における重要なセキュリティ脆弱性](#mcpにおける重要なセキュリティ脆弱性)
   - [攻撃ベクター 1：ツールポイズニング](#攻撃ベクター1ツールポイズニング)
   - [攻撃ベクター 2：ラグプル攻撃](#攻撃ベクター2ラグプル攻撃)
5. [ETDI：拡張ツール定義インターフェースによる MCP の強化](#etdi拡張ツール定義インターフェースによるmcpの強化)
6. [OAuth 強化 ETDI によるセキュリティの向上](#oauth強化etdiによるセキュリティの向上)
7. [ETDI の戦略的実装考慮事項](#etdiの戦略的実装考慮事項)
8. [結論](#結論)
9. [参考文献](#参考文献)

## 1. はじめに：セキュアな MCP の必要性

Model Context Protocol（MCP）は、AI アプリケーション、特に大規模言語モデル（LLM）を活用するアプリケーションに動的で実世界のコンテキストを提供する方法を標準化する重要な一歩を表しています。外部ツール、多様なデータソース、補助システムとのシームレスな統合を促進することで、MCP は LLM が複雑なタスクを実行し、タイムリーな情報にアクセスし、より関連性が高く強力な相互作用を提供することを可能にします。

しかし、現在の MCP 仕様の本質的な開放性と拡張性は、イノベーションを促進する一方で、重要なセキュリティ脆弱性を意図せず導入しています。ツールの真正性と整合性を検証する堅牢なメカニズムの欠如により、ユーザーとシステムは**ツールポイズニング**や**ラグプル**などの高度なツールベースの攻撃にさらされています。これらの攻撃は、機密データの流出、不正なシステム操作、AI アプリケーションに対するユーザーの信頼の大幅な低下など、深刻な結果をもたらす可能性があります。

この文書では、**拡張ツール定義インターフェース（ETDI）**を導入することで、これらの緊急のセキュリティ懸念に対処します。ETDI は、既存の MCP フレームワークと統合するよう細心に設計されたセキュリティ強化レイヤーとして構想されています。コアプロトコルを根本的に変更することなく、ツールに対する検証可能な信頼と整合性を提供することを目的とし、その柔軟性を保持しながらセキュリティの欠点に対処します。暗号化検証と明示的な同意に焦点を当てることで、ETDI は MCP エコシステムを保護するための実用的で効果的なソリューションを提供します。

## 2. MCP エコシステムの理解：アーキテクチャ概要

MCP は分散クライアント・サーバーモデルで動作し、LLM に必要なコンテキストと機能を提供するために様々なエンティティ間の相互作用を促進します。主要なコンポーネントには以下が含まれます：

- **ホストアプリケーション**：これらは、AI 搭載デスクトップアプリケーション（例：Claude Desktop）、AI 拡張機能を持つ統合開発環境（IDE）、または専門的な AI 駆動プラットフォームなど、ユーザーの主要なインターフェースです。ユーザー、LLM、および MCP コンポーネント間の相互作用を調整します。

- **MCP クライアント**：ホストアプリケーション内に組み込まれたこれらのソフトウェアコンポーネントは、MCP サーバーの発見、接続管理、相互作用を担当します。ホストアプリケーションと MCP サーバー間でリクエストとレスポンスを変換する仲介者として機能します。

- **MCP サーバー**：これらは、MCP クライアントに特定の機能を公開する専用プログラムまたはサービスです。これらの機能は、シンプルなユーティリティ機能から複雑なデータ処理サービスまで多岐にわたります。各サーバーは一連のツール、リソース、またはプロンプトを管理します。

- **ツール**：これらは、LLM が MCP サーバー経由で呼び出して特定のアクション（例：コード実行、API からのデータ取得、計算実行）を実行できる個別の機能またはサービスです。ツールは LLM の機能を拡張するアクティブなコンポーネントです。

- **リソース**：これらは、LLM がコンテキストの理解や応答の情報提供のためにアクセスできるデータソースまたは情報リポジトリ（例：ナレッジベース、ユーザーの文書、データベース）を表します。

- **プロンプト**：これらは、LLM がツールやリソースを効果的かつ特定のタスクに使用するよう導く事前定義されたテンプレートまたは指示であり、最適で一貫したパフォーマンスを確保します。

## 3. 運用ダイナミクス：標準的な MCP フロー

Model Context Protocol は、初期化からツール実行まで、定義された一連のステップを通じて相互作用を促進します。

### 初期化と発見フェーズ

このフェーズでは、MCP クライアントとサーバー間の接続と認識を確立します。Model Context Protocol は、一連の明確に定義された相互作用を通じて動作します：

1. **アプリケーション起動とクライアント初期化**：ホストアプリケーションが開始されると、組み込まれた MCP クライアントを初期化します。

2. **サーバーハンドシェイク**：MCP クライアントは、既知または発見可能な MCP サーバーとハンドシェイクを実行します。これは通常、初期化リクエストとレスポンスを含み、サーバーがその機能、サポートされているプロトコルバージョン、その他のメタデータを共有する場合があります。

3. **ツールリスト**：クライアントは、listTools（または類似の）コマンドを使用して、接続された MCP サーバーから利用可能なツールのリストを要求します。

4. **ツール定義交換**：サーバーは、利用可能なツールの定義で応答します。これらの定義には通常、人間が読める説明、機械が読める名前または ID、および各ツールの期待される入力パラメータと出力形式を定義する JSON スキーマが含まれます。

### ツール呼び出しと使用フェーズ

このフェーズでは、ユーザーのリクエストに応じてツールがどのように選択され実行されるかを説明します。

1. **ユーザーリクエスト**：ユーザーがホストアプリケーションと相互作用し、外部ツールの使用を必要とする可能性のあるリクエストを行います（例：「パリへのフライトを検索」、「この文書を要約」）。

2. **LLM によるツール選択**：ホストアプリケーションは、しばしば LLM と連携して、ユーザーのリクエストを処理します。利用可能なツールの説明とスキーマを提供された LLM は、どのツール（もしあれば）が適切で、どのパラメータが必要かを決定します。

3. **権限リクエスト（条件付き）**：選択されたツールが特定の権限（例：位置情報、連絡先へのアクセス、またはコストが発生するアクションの実行）を必要とする場合、またはユーザーがこのツールに初めて遭遇する場合、MCP クライアント（ホストアプリケーション経由）はユーザーに明示的な承認を求める場合があります。

4. **ツール呼び出し**：承認されると（必要な場合）、MCP クライアントは関連する MCP サーバーに invokeTool（または類似の）リクエストを送信し、ツール ID と LLM によって特定されたパラメータを指定します。

5. **ツール実行**：MCP サーバーは、リクエストを実際のツールに委任し、ツールがその機能を実行します。

6. **結果の伝播**：ツールは出力（またはエラーメッセージ）を MCP サーバーに返し、MCP サーバーはそれを MCP クライアントに中継します。

7. **コンテキスト拡張と応答生成**：MCP クライアントは、ツールの結果をホストアプリケーションに提供します。これらの結果は通常、LLM のコンテキストに追加されます。LLM は、この拡張されたコンテキストを使用して、ユーザーの元のクエリに対する最終的で情報に基づいた応答を生成します。

## 4. MCP における重要なセキュリティ脆弱性

標準的な MCP フローは機能的である一方で、ツールのアイデンティティと整合性を検証する堅牢なメカニズムの欠如により、重大なセキュリティ弱点を抱えています。2 つの主要な攻撃ベクターが浮上します：

### 攻撃ベクター 1：ツールポイズニング

#### 定義とメカニズム

ツールポイズニングは、悪意のあるアクターが正当で信頼できる、または無害なツールになりすますツールを展開する際に発生します。攻撃者は、ユーザーまたは LLM を欺いて悪意のあるツールを選択し承認させることで、不正なアクセスや機能を獲得することを目的としています。

#### 脆弱性分析

- **真正性検証の欠如**：ユーザーと MCP クライアントには、ツールの真の起源や真正性を検証する信頼できる方法がありません。ツール名、説明、さらにはプロバイダー名も簡単に偽装できます。

- **区別できない複製**：悪意のあるツールが正当なツールのメタデータ（名前、説明、スキーマ）を完全に模倣する場合、選択プロセス中にユーザーや LLM がそれらを区別することは事実上不可能になります。

- **信頼の悪用**：攻撃者は、馴染みのあるツール名や評判の良いプロバイダー名に対するユーザーの信頼を悪用します。

- **検証不可能な主張**：ツールは、この主張を検証するメカニズムなしに、その説明で「セキュア」または「公式」であると主張できます。

**影響**：成功したツールポイズニングは、データ盗難、マルウェアのインストール、不正なシステムアクセス、金銭的損失、または悪意のある目的での LLM 出力の操作につながる可能性があります。

#### 攻撃シナリオの例

1. **正当なツール**：有名な企業「TrustedSoft Inc.」が、文書をスキャンして個人識別情報（PII）を検出し、結果を報告するよう設計された「SecureDocs Scanner」という正当な MCP ツールを提供しています。

2. **悪意のある模倣**：攻撃者が、同じく「SecureDocs Scanner」という名前のツールをホストする悪意のある MCP サーバーを展開します。彼らは説明、JSON スキーマを細心に複製し、ツールのメタデータでプロバイダーとして「TrustedSoft Inc.」を主張さえします。

3. **発見**：ユーザーの MCP クライアントが、正当と悪意の両方の「SecureDocs Scanner」ツールを発見します。同一の表示により、それらは重複として表示されるか、クライアントが重複排除を行い、発見順序などの任意の要因に基づいて悪意のあるものを優先する可能性があります。

4. **ユーザーの欺瞞**：信頼できるツールを使用するつもりのユーザーが、悪意のあるバージョンに対応するエントリを選択するか、LLM が一致する説明に基づいてそれを選択します。

5. **悪意のあるアクション**：呼び出されると、悪意のある「SecureDocs Scanner」は PII をスキャンしません。代わりに、処理された文書の全内容を攻撃者制御のサーバーに密かに流出させ、外観を維持するために偽の「PII が見つかりませんでした」メッセージを返す可能性があります。

### 攻撃ベクター 2：ラグプル攻撃

#### 定義とメカニズム

ラグプル攻撃（このコンテキストでは「おとり商法」とも呼ばれる）は、既に承認されたツールの機能や権限要件が、初期のユーザー承認後に悪意を持って変更される際に発生します。ツールは最初に良性の動作を示して信頼と承認を得て、その後、再同意リクエストをトリガーすることなく不正なアクションを実行するよう変更されます。

#### 脆弱性分析

- **承認後の変更**：核心的な問題は、ユーザーが初期承認を与えた後に、ツールの動作やデータアクセス権限がサーバー側で変更される可能性があることです。

- **整合性チェックの欠如**：標準的な MCP クライアントは通常、承認されたツールの定義やハッシュを使用のたびに再検証しません。特にツールの名前/バージョン文字列が変更されていない場合は特にそうです。

- **再承認トリガーの欠如**：ツールの識別子（名前やバージョン文字列など）が変更されない場合、またはクライアントがスキーマや説明の微妙な変更を検出するよう設計されていない場合、ユーザーに再承認プロンプトは表示されません。

- **既存の信頼の悪用**：攻撃は、初期の良性承認中に確立された信頼を活用します。

**影響**：ラグプルは、ユーザーがそのツールと共有することに同意したことのない機密データ（例：会話、ファイル、個人情報）への不正アクセスにつながり、初期の権限モデルを効果的にバイパスします。発見されると、ユーザーの信頼を大幅に損ないます。

#### 攻撃シナリオの例

1. **初期の良性ツール**：ユーザーが「Daily Wallpaper」ツールをインストールし承認します。このツールのバージョン 1.0 は、単純に公開 API から新しい壁紙画像を取得し、デスクトップの背景として設定します。「インターネットへのアクセス」と「デスクトップ壁紙の変更」の権限のみを要求します。

2. **承認後の変更**：数週間後、「Daily Wallpaper」のプロバイダー（または、サーバーを侵害した攻撃者）がツールのサーバー側ロジックを更新します。再承認を避けるために「Daily Wallpaper v1.0」として識別されるツールは、ユーザーの Documents フォルダーをスキャンして金融キーワードを含むファイルを検索し、それらをアップロードするよう変更されました。

3. **密かな悪用**：次回「Daily Wallpaper」ツールが実行される際（例：システム起動時または日次スケジュール）、通常通り壁紙を取得し設定します。しかし、バックグラウンドで新しい悪意のあるコードも実行し、機密文書を流出させます。

4. **ユーザーの無認識**：ツールの主要機能が期待通りに動作し続け、ツールの識別子と最初に宣言された権限（クライアントの観点から、定義を再取得して詳細に比較しない場合）が変更されていないため、新しい権限プロンプトがトリガーされなかったため、ユーザーはこの変更に気づきません。

## 5. ETDI：拡張ツール定義インターフェースによる MCP の強化

拡張ツール定義インターフェース（ETDI）は、ツールポイズニングとラグプルの脆弱性に特に対処するよう設計された MCP へのセキュリティレイヤー拡張として提案されています。ETDI は、ツール定義に対する検証可能なアイデンティティと整合性を導入することでこれを達成します。

### ETDI の基本的なセキュリティ原則

ETDI は 3 つの核心的なセキュリティ原則に基づいて構築されています：

1. **暗号化アイデンティティと真正性**：ツールは、暗号化署名を通じて確立された検証可能なアイデンティティを持つ必要があります。これにより、ツールの主張された起源と作成者が認証でき、なりすましを防ぎます。

2. **不変でバージョン管理された定義**：ツールの各異なるバージョンは、一意で暗号化署名された不変の定義を持つ必要があります。これは、ツールの機能、説明、または権限要件への変更が、新しい署名を持つ新しいバージョンを必要とし、不正な変更を検出可能にすることを意味します。

3. **明示的で検証可能な権限**：ツールの機能とそれが必要とする権限は、その署名された定義内で明示的に定義される必要があります。MCP クライアントは、これらをユーザーに確実に提示し、強制できます。

### ETDI 対策：ツールポイズニングの阻止

ETDI は、悪意のあるツールが正当なツールになりすますことを計算上実行不可能にすることで、ツールポイズニングを効果的に軽減します。

**ETDI がツールポイズニングを防ぐ方法：**

1. **プロバイダーキー**：正当なツールプロバイダーが公開/秘密暗号化キーペアを生成します。公開キーは、信頼できるレジストリを通じて、またはホストアプリケーションと共に配布されることで、MCP クライアントが利用できるようになります。

2. **署名された定義**：プロバイダーがツール（またはその新しいバージョン）を定義する際、完全なツール定義（名前、説明、スキーマ、バージョン、権限要件を含む）を秘密キーで署名します。

3. **クライアント検証**：MCP クライアント（ETDI ロジックを装備）がツールを発見する際、これらの署名された定義を受信します。クライアントは、主張されたプロバイダーの公開キーを使用して署名を検証します。

4. **未検証ツールのフィルタリング**：署名が無効（つまり、主張されたプロバイダーの秘密キーで署名されていない）または欠落している場合、ツールは未検証または潜在的に悪意があるとフラグが立てられます。クライアントは、そのようなツールを隠す、ユーザーに警告する、または使用を完全に防ぐことを選択できます。

5. **真正性の保証**：ユーザーには、真正性と整合性が暗号化的に検証されたツールのみが提示されます。悪意のあるアクターは、正当なプロバイダーの秘密キーにアクセスすることなく、所有していないツールの有効な署名を偽造することはできません。

### ETDI 対策：ラグプルの防止

ETDI は、ツールの定義への変更を検出可能にし、必要に応じて再評価と再承認を強制することで、ラグプルを防ぎます。

**ETDI がラグプルを防ぐ方法：**

1. **不変の署名された定義**：ツールの各バージョンは、プロバイダーによって暗号化署名された一意で完全な定義を持ちます。この署名は、ツールの名前、バージョン文字列、説明、スキーマ、明示的な権限リストをカバーします。

2. **クライアントが承認状態を保存**：ユーザーがツール（例：署名 S1 を持つ「WeatherReporter v1.0」）を承認すると、ETDI 対応 MCP クライアントは承認だけでなく、特定のバージョン識別子と承認されたツールの署名（または署名された定義のハッシュ）も安全に保存します。

3. **後続使用時の検証**：
   - **バージョン変更検出**：MCP サーバーが新しいバージョン番号を持つツール定義（例：署名 S2 を持つ「WeatherReporter v2.0」）を返す場合、クライアントは保存された承認バージョン（「v1.0」）と比較してバージョン変更を検出します。これにより、新しい定義（および変更された権限）をユーザーに提示する再承認プロセスが自動的にトリガーされます。
   - **整合性違反検出**：サーバーがバージョン番号を変更せずに変更されたツール定義を返そうとする場合（つまり、まだ「WeatherReporter v1.0」であると主張するが、基礎となる定義またはその署名が変更されている）、クライアントの検証は失敗します。署名が定義と一致しなくなったか、現在の定義の署名/ハッシュが承認された「v1.0」の保存された署名/ハッシュと一致しないことを検出します。

4. **ユーザーのエンパワーメント**：いずれの場合も—正当なバージョンアップグレードまたは悪意のある変更—変更されたツールが使用される前に、ユーザーに警告および/または再承認が求められます。密かな変更は防がれます。

## 6. OAuth 強化 ETDI によるセキュリティの向上

直接的な暗号化署名を持つ ETDI が強固な基盤を提供する一方で、OAuth 2.0 などの確立された認可フレームワークと統合することで、標準化、エコシステムの相互運用性、中央集権的な信頼管理の面で大きな利点を提供できます。核心的なアイデアは、通常はアイデンティティプロバイダー（IdP）によって署名された JSON Web Token（JWT）である OAuth トークンを、ツール定義のキャリアとして、またはツールの有効性とそのプロバイダーのアイデンティティの証明として使用することです。

### OAuth 2.0 のアーキテクチャ統合

この強化されたアーキテクチャでは、OAuth アイデンティティプロバイダー（IdP）を中央の信頼アンカーとして導入します。

このモデルでは：

- ツールプロバイダーが IdP に OAuth クライアントとして登録します。
- IdP がツールプロバイダーを認証し、署名された OAuth トークン（例：JWT）を発行します。
- これらのトークンは、ツール定義を直接含むか、プロバイダー ID、ツール ID、バージョン、認可されたスコープ（権限）などのメタデータと共に安全に保存された定義を参照できます。
- MCP サーバーは、ホストするツールのこれらの OAuth トークンを取得し、MCP クライアントに提示します。
- MCP クライアントは、これらのトークンを IdP で検証（または IdP の公開キーを使用）して、ツールの真正性、整合性、認可された権限を確認します。

### OAuth による強化された保護フロー

#### OAuth 強化ツールポイズニング防御

IdP が中央権威として機能します。悪意のあるサーバーは、正当に所有していない、または提供する権限がないツールについて、信頼できる IdP から有効な OAuth トークンを取得できません。クライアントは、認識された IdP からのトークンによって裏付けられたツールのみを信頼します。

#### OAuth 強化ラグプル防御

OAuth トークンは本質的に、ツール定義（またはそれらへの参照）を特定のバージョンと権限スコープと結び付けます。

- **バージョンとスコープの結び付け**：IdP は、ツールバージョンとそのバージョンに付与された正確な OAuth スコープ（権限）を指定するトークンを発行します。
- **クライアント検証**：MCP クライアントはトークンを検証し、トークン内のバージョンとスコープを保存された承認バージョンとスコープと比較します。
- **変更の検出**：
  - トークン内のバージョンが新しい場合、再承認が求められます。
  - トークン内のスコープが変更された（例：拡張された）場合、再承認が求められます。
  - サーバーが、実際にサーバー上で新しいスコープを必要とする方法で定義が変更されたツールに対して古いトークンを返そうとする場合、クライアント/IdP が呼び出された操作をトークンのスコープに対して検証できれば、この不一致を捉えることができます。
- **中央集権的な取り消し**：ツールプロバイダーのキーが侵害されたり、ツールが悪意があることが判明した場合、IdP は関連するトークンまたはクライアント認証情報を取り消し、エコシステム全体でツールを中央集権的に無効化できます。

### OAuth 統合の主要な利点

1. **標準化された認証と認可**：広く採用されている業界標準フレームワーク（OAuth 2.0/2.1）を活用し、相互運用性を促進し、カスタム暗号化ソリューションの必要性を減らします。

2. **きめ細かい権限制御**：OAuth スコープは、ツールのきめ細かい権限を定義し強制するための堅牢なメカニズムを提供し、単純なバイナリ承認を超えます。

3. **中央集権的な信頼管理**：IdP が信頼関係、ツールプロバイダーのアイデンティティ、ポリシーを管理する中央ポイントとして機能します。これにより、クライアントの信頼設定が簡素化されます。

4. **プロバイダーとクライアントの実装の簡素化**：ツールプロバイダーとクライアント開発者は、既存の OAuth ライブラリとインフラストラクチャを活用でき、開発努力と複雑さを潜在的に削減できます。

5. **強化された取り消し機能**：OAuth は、トークン取り消しのメカニズムを提供し、侵害されたツールやプロバイダーに対するより迅速で効果的な対応を可能にします。

6. **エコシステムのスケーラビリティ**：複数の IdP がサポートされる場合、連合アイデンティティモデルを通じて大規模なツールとプロバイダーのエコシステムを管理しやすくなります。

## 7. ETDI の戦略的実装考慮事項

ETDI の成功した実装には、いくつかの重要な技術的および運用的考慮事項への慎重な注意が必要です：

### 検証可能な信頼チェーンの確立

- **キー配布メカニズム**：プロバイダーの公開キーを MCP クライアントに安全に配布する方法を確立する必要があります。これには、中央集権的な信頼できるレジストリ、分散型アプローチ、またはホストアプリケーションとの事前配布が含まれる場合があります。

- **証明書権威（CA）モデル**：従来の PKI に類似したモデルを採用し、信頼できる CA がツールプロバイダーの証明書を発行し検証することを検討できます。

### 堅牢なバージョン制御と不変性

- **セマンティックバージョニング**：ツールバージョンの明確で一貫した命名規則を確立し、メジャー、マイナー、パッチの変更を区別します。

- **不変ストレージ**：署名されたツール定義が改ざんされないよう、不変ストレージソリューション（ブロックチェーンベースのシステムや暗号化ハッシュチェーンなど）の使用を検討します。

### きめ細かく明示的な権限管理

- **標準化された権限スキーマ**：ツール間で一貫した権限モデルを確保するために、標準化された権限スキーマまたは分類法を開発します。

- **動的権限評価**：実行時にツールの動作を監視し、宣言された権限との一致を確保するメカニズムを実装します。

### パフォーマンスオーバーヘッドの評価と軽減

- **署名検証の最適化**：暗号化署名検証がツール発見と呼び出しプロセスに大幅な遅延を導入しないよう確保します。

- **キャッシング戦略**：検証されたツール定義と署名の効率的なキャッシングメカニズムを実装し、繰り返し検証の必要性を減らします。

### 後方互換性と採用パスの確保

- **段階的展開**：既存の MCP 実装が ETDI 機能なしで動作し続けることを可能にし、段階的な採用を促進します。

- **レガシーサポート**：ETDI 対応クライアントが、署名されていないツールを適切に処理し、ユーザーに明確な警告を提供できることを確保します。

## 8. 結論

Model Context Protocol は、AI アプリケーションと大規模言語モデルの機能を拡張する上で大きな可能性を持っていますが、現在の仕様にはツールポイズニングとラグプル攻撃に対する重大な脆弱性があります。拡張ツール定義インターフェース（ETDI）は、暗号化アイデンティティ、不変のバージョン管理、明示的な権限付与を通じて、これらのセキュリティ懸念に対処する包括的なソリューションを提供します。

OAuth 2.0 との統合により、ETDI はさらに強化され、標準化された認可フレームワーク、きめ細かい権限制御、中央集権的な信頼管理を提供します。この組み合わせにより、MCP エコシステムのセキュリティ態勢が大幅に向上し、ユーザーと開発者の両方にとってより安全で信頼できる環境が確保されます。

ETDI の採用には慎重な計画と実装が必要ですが、AI 駆動アプリケーションの継続的な成長と採用において、セキュリティと信頼を維持するために不可欠です。暗号化検証と明示的な同意に焦点を当てることで、ETDI は MCP の柔軟性と拡張性を保持しながら、そのセキュリティの欠点に対処する実用的で効果的なソリューションを提供します。

## 9. 参考文献

- Model Context Protocol 仕様：（例：https://modelcontextprotocol.io/specification - 利用可能な場合は実際の URL に置き換えてください）
- OAuth 2.1 認可フレームワーク：https://oauth.net/2.1/
- JSON Web Signatures（JWS）RFC 7515：https://datatracker.ietf.org/doc/html/rfc7515
- JSON Web Token（JWT）RFC 7519：https://datatracker.ietf.org/doc/html/rfc7519

---

## 翻訳概要

この文書は、Model Context Protocol（MCP）のセキュリティ脆弱性を分析し、拡張ツール定義インターフェース（ETDI）という解決策を提案する技術文書です。主な内容は以下の通りです：

**主要なセキュリティ脅威**：
- ツールポイズニング：悪意のあるツールが正当なツールになりすます攻撃
- ラグプル攻撃：承認後にツールの動作が悪意を持って変更される攻撃

**ETDI の解決策**：
- 暗号化署名によるツールの真正性検証
- 不変のバージョン管理による変更の検出
- OAuth 2.0 統合による標準化されたセキュリティ制御

この文書は、AI アプリケーションのセキュリティ強化において重要な技術的指針を提供しており、開発者やセキュリティ専門家にとって価値のある資料となっています。